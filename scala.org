* TODO resume here
subsection "Abstract Classes"
https://www.scala-exercises.org/scala_tutorial/object_oriented_programming
* How to clone some of these projects
sbt new scala/hello-world.g8
sbt new scala/scalatest-example.g8
* some sbt commands
** sbt         # interactive mode, I guess
*** from the project directory, run `sbt`
*** from within sbt, run `~run`
The ~ makes it rerun after each edit.
** sbt console # a repl
** sbt new <template>
** sbt compile # optional? can simply run without first compiling
** sbt ~run    # reruns after each change
** sbt run
** sbt test
* Scala syntax
** function application
*** operators are just symbol-named methods
 3 + 2 == 3.+(2)
*** any method, not just symbol-named ones, can be used infix
 1.to(10) == 1 to 10
** definitions
*** of non-function values
 val x = 3
*** of functions
Return type is optional.
def power(x: Double, y: Int): Double = ...
*** "def statements" are reevaluated at each call
whereas "val" statements are evaluated once.
"def" statements can also be used to define (static) values,
but (I'm guessing) it's inefficient.
** evaluation
*** identifiers can have wacky symbols
x1 * +?%& vector_++ counter_=
*** call-by-name ~ call-by-value ~~~ top-down ~ bottom-up
*** Scala is "usually" call-by-value
Which I think means strict.
But they mention call-by-name (lazy?) as if it is possible:
https://www.scala-exercises.org/scala_tutorial/definitions_and_evaluation

** scope
*** the last elt in a {}-block is its value
*** definitions in a block
are accessible only inisde it
shadow outside names
*** functions can use blocks to define private subfunctions
def sqrt(x: Double) = {
  def sqrtIter(guess: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def improve(guess: Double) =
    (guess + x / guess) / 2

  def isGoodEnough(guess: Double) =
    abs(square(guess) - x) < 0.001

  sqrtIter(1.0)
}
*** semicolons can separate statements on the same line
*** use parens to write multi-line expressions
or put the operator at the end of the first line
*** the top-level objects of a file are "objects"
and there care be more than one in a file, unlike Java
*** packages
**** like-packaged objects share
if a statement like
  package foo
appears at the top of two files,
then their definitions are available to each other.
**** fully qualified names require no import statements
package quux
object Quux {
  foo.Bar.someMethod // foo is the package name
}
**** import statements let you omit most of a name
package quux
import foo.Bar
object Quux {
  Bar.someMethod
}
*** automatic imports
All members of package scala
All members of package java.lang
All members of the singleton object scala.Predef.
*** types and values have separate namespaces
** types
https://www.scala-exercises.org/scala_tutorial/structuring_information
*** "case class": product types
case class Note(
  name: String,
  duration: String,
  octave: Int )
*** "sealed trait": sum types
sealed trait Symbol
case class Note(name: String, duration: String, octave: Int) extends Symbol
case class Rest(duration: String) extends Symbol
*** "match-case": pattern matching
def symbolDuration(symbol: Symbol): String =
  symbol match {
    case Note(name, duration, octave) => duration
    case Rest(duration) => duration
  }
*** equals for case classes is defined automatically
it compares their values
*** enums are not case classes
because they are not products. Example:
sealed trait NoteName
case object A extends NoteName
case object B extends NoteName
...
case object G extends NoteName
** higher-order functions
def foo(f: Int => Int, a: Int, b: Int): Int
** higher-kinded types
They use brackets for type parameters,
whereas values use parentheses. Example:

res1: List[List[Int]] = List(List(0), List(1, 2))
** lambda expressions
(x: Int, y: Int) => x + y
*** explicit return type is optional
scala> ((x : Int) => (x*x : Int))(3)
res5: Int = 9
** standard types
*** List
**** values are written "List(elt,elt)"
**** cons is written ::
**** map, filter, etc. are method calls
List(1, 2, 3).flatMap { x =>
    List(x, 2 * x, 3 * x)
  }
**** "flatmap" is Haskell's concatmap
*** Option = Haskell's Maybe
Option T = None | Some T       -- Haskell-style
also has map, filter, flatmap
*** Try
Throwable exception =>         -- Haskell-style
  Try A = Success A | Failure exception
*** Either
** operators ending in (:)
https://www.scala-exercises.org/scala_tutorial/standard_library
*** are (by convention?) right-associative
e.g. A :: B :: C is interpreted as A :: (B :: C).
*** are method calls of the right-hand operand
So you can write
Nil.::(4).::(3).::(2).::(1)
** syntactic sugar
*** string interpolation
def greet(name: String): String =
  s"Hello, $name!"
def greet(name: String): String =
  s"Hello, ${name.toUpperCase}!"
*** tuple accessors
(1,2)._1 = 1
*** functions are objects with apply methods
these two types are synonyms:
  A => B
  scala.Function1[A, B]
Function2 has 2 args, etc.
*** for expressions
for (x <- xs; y <- ys) yield (x, y)
for {
  x <- xs if x % 2 == 0
  y <- ys
} yield (x, y)
*** function calls can optionally make parameter names explicit
and if you do, you can reorder them
Range(start = 1, end = 10, step = 2)
*** BEWARE: default values
case class Range(start: Int, end: Int, step: Int = 1)
*** BEWARE: "repeated parameters"
You can define a function that can receive an arbitrary number of parameters (of the same type) as follows:
def average(x: Int, xs: Int*): Double =
  (x :: xs.to[List]).sum.toDouble / (xs.size + 1)
And given such a function, a list can take the place of the many parameters:
  val xs: List[Int] = â€¦
  average(1, xs: _*)
*** type aliases
Just like Haskell.
type Result = Either[String, (Int, Int)]
** OOP
*** defining a class
class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y
}
=>
A new type, named Rational.
A constructor Rational to create elements of this type.
*** creating an instance
new Rational(3,2)
*** TODO (seems useful): private members
class Rational(x: Int, y: Int) {
  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = gcd(x, y)
  def numer = x / g
  def denom = y / g
  ...
}
*** "this" can usually be omitted
When defining a member function of a class with field "x",
one can simply write "x" instead of "this.x".
But to refer to the entire object, one must use "this".
*** imposing "require" on fields
class Rational(x: Int, y: Int) {
  require(y > 0, "denominator must be positive")
  ...
}
failure throws an IllegalArgumentException
*** BEWARE: auxiliary constructors
class Rational(x: Int, y: Int) {
  def this(x: Int) = this(x, 1)
  ...
}
*** defining operators
They are no different.
  def + (r: Rational) =
    new Rational(
      numer * r.denom + r.numer * denom,
      denom * r.denom
    )
*** precedence: determined by the first letter
(all letters)
|
^
&
< >
= !
:
+ -
* / %
(all other special characters)
** assertions
Just like Python.
  assert(x >= 0)
* tail-recursion
** to qualify, a function must
call itself as the last thing it does -- and not, say,
return the product of something with the call to itself
** a helpful example
https://www.scala-exercises.org/scala_tutorial/tail_recursion
at the bottom of the page they rewrite factorial to be tail-rec
* importing Java libraries in Scala
https://alvinalexander.com/scala/scala-import-java-classes-packages-examples
of particular interest: aliases
